class Module
  rdl_nowrap

  type 'self.constants', '() -> Array<Fixnum>' # also constants(inherited), but undocumented
  type 'self.nesting', '() -> Array<Module>'
  type 'self.new', '() -> Module'
  type 'self.new', '() { (Module) -> %any } -> Module'

  type :<, '(Module other) -> %bool or nil'
  type :<=, '(Module other) -> %bool or nil'
  type :<=>, '(Module other) -> -1 or 0 or 1 or nil'
  type :==, '(%any other) -> %bool'
  type :equal, '(%any other) -> %bool'
  type :eql, '(%any other) -> %bool'
  type :===, '(%any other) -> %bool'
  type :>, '(Module other) -> %bool or nil'
  type :>=, '(Module other) -> %bool or nil'
  type :ancestors, '() -> Array<Module>'
  type :autoload, '(Symbol module, String filename) -> nil'
  type :autoload?, '(Symbol name) -> String or nil'
  type :class_eval, '(String, ?String filename, ?Fixnum lineno) -> %any'
  type :class_exec, '(*%any args) { (*%any args) -> %any } -> %any'
  type :class_variable_defined?, '(Symbol or String) -> %bool'
  type :class_variable_get, '(Symbol or String) -> %any'
  type :class_variable_set, '(Symbol or String, %any) -> %any'
  type :class_variables, '(?%bool inherit) -> Array<Symbol>'
  type :const_defined?, '(Symbol or String, ?%bool inherit) -> %bool'
  type :const_get, '(Symbol or String, ?%bool inherit) -> %any'
  type :const_missing, '(Symbol) -> %any'
  type :const_set, '(Symbol or String, %any) -> %any'
  type :constants, '(?%bool inherit) -> Array<Symbol>'
  type :freeze, '() -> self'
  type :include, '(*Module) -> self'
  type :include?, '(Module) -> %bool'
  type :included_modules, '() -> Array<Module>'
  rdl_alias :inspect, :to_s
  type :instance_method, '(Symbol) -> UnboundMethod'
  type :instance_methods, '(?%bool include_super) -> Array<Symbol>'
  type :method_defined?, '(Symbol or String) -> %bool'
  type :module_eval, '(String, ?String filename, ?Fixnum lineno) -> %any' # matches rdoc example but not type
  type :module_exec, '(*%any args) { (*%any args) -> %any } -> %any'
  type :name, '() -> String'
  type :prepend, '(*Module) -> self'
  type :private_class_method, '(*(Symbol or String)) -> self'
  type :private_constant, '(*Symbol) -> self'
  type :private_instance_methods, '(?%bool include_super) -> Array<Symbol>'
  type :private_method_defined?, '(Symbol or String) -> %bool'
  type :protected_instance_methods, '(?%bool include_super) -> Array<Symbol>'
  type :protected_method_defined?, '(Symbol or String) -> %bool'
  type :public_class_method, '(*(Symbol or String)) -> self'
  type :public_constant, '(*Symbol) -> self'
  type :public_instance_method, '(Symbol) -> UnboundMethod'
  type :public_instance_methods, '(?%bool include_super) -> Array<Symbol>'
  type :public_method_defined?, '(Symbol or String) -> %bool'
  type :remove_class_variable, '(Symbol) -> %any'
  type :singleton_class?, '() -> %bool'
  type :to_s, '() -> String'
# private methods below here
  type :alias_method, '(Symbol new_name, Symbol old_name) -> self'
  type :append_features, '(Module) -> self'
  rdl_alias :attr, :attr_reader
  type :attr_accessor, '(*(Symbol or String)) -> nil'
  type :attr_reader, '(*(Symbol or String)) -> nil'
  type :attr_writer, '(*(Symbol or String)) -> nil'
  type :define_method, '(Symbol, Method) -> Symbol'
  type :define_method, '(Symbol) { (*%any) -> %any } -> Symbol'
  type :extend_object, '(%any) -> %any'
  type :extended, '(Module othermod) -> %any'
  type :included, '(Module othermod) -> %any'
  type :method_added, '(Symbol method_name) -> %any'
  type :method_removed, '(Symbol method_name) -> %any'
  type :module_function, '(*(Symbol or String)) -> self'
  type :prepend_features, '(Module) -> self'
  type :prepended, '(Module othermod) -> %any'
  type :private, '(*(Symbol or String)) -> self'
  type :protected, '(*(Symbol or String)) -> self'
  type :public, '(*(Symbol or String)) -> self'
  type :refine, '(Class) { (%any) -> %any } -> self' # ??
  type :remove_const, '(Symbol) -> %any'
  type :remove_method, '(Symbol or String) -> self'
  type :undef_method, '(Symbol or String) -> self'
  type :using, '(Module) -> self'
end
